{{- /*gotype:github.com/prisma/photongo/generator.Root*/ -}}

type input struct {
	name   string
	fields []field
	value  interface{}
}

type field struct {
	// The name of the field.
	name string

	// an action for input fields, e.g. `contains` // TODO maybe create separate field struct for input types
	action string

	// whether the fields is a list of items
	list bool

	// whether the a list field should be wrapped in an object
	wrapList bool

	// value contains the field value. if nil, fields will contain a subselection.
	value interface{}

	// fields contains a subselection of fields. If not nil, value will be undefined.
	fields []field
}

type query struct {
	// client holds the photon client
	client *Client

	// operation describes the PQL operation: query, mutation or subscription
	operation string

	// name describes the operation; useful for tracing
	name string

	// method describes a crud operation
	method string

	// model contains the Prisma model name
	model string

	// inputs contains the query
	inputs []input

	// outputs contains the return fields
	outputs []field
}

func (q query) build() string {
	var builder strings.Builder

	builder.WriteString(q.operation + " " + q.name)
	builder.WriteString("{")
	builder.WriteString(q.method + q.model)
	builder.WriteString("(")

	for _, i := range q.inputs {
		builder.WriteString(i.name)

		builder.WriteString(":")

		if i.value != nil {
			builder.WriteString(value(i.name, i.value))
		} else {
			builder.WriteString(buildFields(false, false, i.fields))
		}

		builder.WriteString(",")
	}

	builder.WriteString(")")
	builder.WriteString(" ")
	builder.WriteString("{")

	for _, o := range q.outputs {
		builder.WriteString(o.name + " ")
	}

	builder.WriteString("}")
	builder.WriteString("}")

	return builder.String()
}

func buildFields(list bool, wrapList bool, fields []field) string {
	var builder strings.Builder

	if !list {
		builder.WriteString("{")
	}

	for _, f := range fields {
		if wrapList {
			builder.WriteString("{")
		}

		if f.name != "" {
			builder.WriteString(f.name)
		}

		if f.name != "" && f.action != "" {
			builder.WriteString("_" + f.action)
		}

		if f.name != "" {
			builder.WriteString(":")
		}

		if f.list {
			builder.WriteString("[")
		}

		if f.fields != nil {
			builder.WriteString(buildFields(f.list, f.wrapList, f.fields))
		}

		builder.WriteString(value(f.name, f.value))

		if f.list {
			builder.WriteString("]")
		}

		if wrapList {
			builder.WriteString("}")
		}

		builder.WriteString(",")
	}

	if !list {
		builder.WriteString("}")
	}

	return builder.String()
}

func (q query) exec(ctx context.Context, v interface{}) error {
	if q.client == nil {
		panic("client.Connect() needs to be called before sending queries")
	}

	s := q.build()

	if debug == Info {
		log.Printf("prisma query: `%s`", s)
	}

	return q.client.do(ctx, s, &v)
}

func value(name string, value interface{}) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf(`%q`, v)
	case *string:
		if v == nil {
			return "null"
		}
		return fmt.Sprintf(`%q`, *v)
	case bool:
		return fmt.Sprintf(`%t`, v)
	case *bool:
		if v == nil {
			return "null"
		}
		return fmt.Sprintf(`%t`, *v)
	case int:
		return fmt.Sprintf(`%d`, v)
	case *int:
		if v == nil {
			return "null"
		}
		return fmt.Sprintf(`%d`, *v)
	case float64:
		return fmt.Sprintf(`%f`, v)
	case *float64:
		if v == nil {
			return "null"
		}
		return fmt.Sprintf(`%f`, *v)
	case DateTime:
		return fmt.Sprintf(`"%s"`, v.UTC().Format(RFC3339Milli))
	case *DateTime:
		if v == nil {
			return "null"
		}
		return fmt.Sprintf(`"%s"`, v.UTC().Format(RFC3339Milli))
	case Direction:
		return string(v)
	case nil:
		return ""

	{{ range $t := $.DMMF.Datamodel.Enums }}
		case {{ $t.Name}}:
			return fmt.Sprintf(`%s`, v)
		case *{{ $t.Name}}:
			if v == nil {
				return "null"
			}
			return fmt.Sprintf(`%s`, *v)
	{{ end }}

	default:
		panic(fmt.Errorf("no branch for field %s of type %T", name, v))
	}
}
