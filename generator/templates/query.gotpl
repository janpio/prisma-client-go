{{- /*gotype:github.com/prisma/photongo/generator.Root*/ -}}

type Direction string

const (
	ASC Direction  = "ASC"
	DESC Direction = "DESC"
)

{{ range $model := $.DMMF.Datamodel.Models }}
	{{ $name := $model.Name.GoLowerCase }}
	{{ $nameUpper := $model.Name.GoCase }}
	{{ $nsQuery := (print $name "Query") }}

	{{/* Namespace declaration */}}
	// {{ $nameUpper }} acts as a namespaces to access query methods for the {{ $nameUpper }} model
	var {{ $nameUpper }} = {{ $nsQuery }}{}

	// {{ $nsQuery }} exposes query functions for the {{ $name }} model
	type {{ $nsQuery }} struct {
		{{- range $field := $model.Fields }}
			{{/* Filter non-relations only for now */}}
			{{- if $field.Kind.IncludeInStruct -}}
				// {{ $field.Name.GoCase }}
				//
				// @{{ if $field.IsRequired }}required{{ else }}optional{{ end }}
				{{- if $field.IsUnique }}
					// @unique
				{{- end }}
				{{ $field.Name.GoCase }} {{ $nsQuery }}{{ $field.Name.GoCase }}{{ $field.Type }}
			{{ end }}

			{{- if $field.Kind.IsRelation }}
				{{ $field.Name.GoCase }} {{ $nsQuery }}{{ $field.Name.GoCase }}Relations
			{{ end }}
		{{- end }}
	}

	{{ range $op := $.DMMF.Operators }}
		func ({{ $nsQuery }}) {{ $op.Name }}(params ...i{{ $nameUpper }}Params) {{ $name }}Params {
			var fields []field

			for _, q := range params {
				fields = append(fields, q.field())
			}

			return {{ $name }}Params{
				data: field{
					name:     "{{ $op.Action }}",
					list:     true,
					wrapList: true,
					fields:   fields,
				},
			}
		}
	{{ end }}

	{{ range $field := $model.Fields }}
		{{ $nsField := print $nsQuery $field.Name.GoCase }}
		{{ $nsFieldParams := (print $name $field.Name.GoCase "SetParams") }}
		{{ $struct := print $nsField $field.Type }}

		// base struct
		type {{ $struct }} struct {}

		{{ $setReturnStruct := "" }}
		{{ if $field.IsRequired }}
			{{ $setReturnStruct = $nsFieldParams }}
		{{ else }}
			{{ $setReturnStruct = (print $name "SetParams") }}
		{{ end}}

		{{ if $field.Kind.IsRelation }}
			type {{ $nsQuery }}{{ $field.Name.GoCase }}Relations struct {}

			{{ range $method := $field.RelationMethods }}
				// {{ $nameUpper }} -> {{ $field.Name.GoCase }}
				//
				// @relation
				// @{{ if $field.IsRequired }}required{{ else }}optional{{ end }}
				func ({{ $nsQuery }}{{ $field.Name.GoCase }}Relations) {{ $method.Name }}(
					params ...i{{ $field.Type.GoCase }}Params,
				) {{ $name }}Params {
					var fields []field

					for _, q := range params {
						fields = append(fields, q.field())
					}

					return {{ $name }}Params{
						data: field{
							name:   "{{ $field.Name.CamelCase }}",
							action: "{{ $method.Action }}",
							fields: fields,
						},
					}
				}
			{{ end }}

			{{/* Load API */}}
			func ({{ $nsQuery }}{{ $field.Name.GoCase }}Relations) Find{{ if $field.IsList }}Many{{ else }}One{{ end }}(
				params ...i{{ $field.Type.GoCase }}Params,
			) {{ $name }}Find{{ if $field.IsList }}Many{{ else }}One{{ end }} {
				var v {{ $name }}Find{{ if $field.IsList }}Many{{ else }}One{{ end }}

				v.query.operation = "query"
				v.query.method = "{{ $field.Name.CamelCase }}"
				v.query.outputs = {{ $field.Type.CamelCase }}Output

				{{/* TODO create a function for this type of field colletion, also used in find.gotpl */}}
				var where []field
				for _, q := range params {
					if query := q.getQuery(); query.operation != "" {
						v.query.outputs = append(v.query.outputs, output{
							name:    query.method,
							inputs:  query.inputs,
							outputs: query.outputs,
						})
					} else {
						where = append(where, q.field())
					}
				}

				if len(where) > 0 {
					v.query.inputs = append(v.query.inputs, input{
						name:   "where",
						fields: where,
					})
				}

				return v
			}

			func (r {{ $nsQuery }}{{ $field.Name.GoCase }}Relations) Link(
				params ...i{{ $field.Type.GoCase }}Params,
			) {{ $setReturnStruct }} {
				var fields []field

				for _, q := range params {
					fields = append(fields, q.field())
				}

				return {{ $setReturnStruct }}{
					data: field{
						name: "{{ $field.Name.CamelCase }}",
						fields: []field{
							{
								name:   "connect",
								fields: fields,
							},
						},
					},
				}
			}
		{{ end }}

		{{ if $field.Kind.IncludeInStruct }}
			// Set the {{ if $field.IsRequired }}required{{ else }}optional{{ end }} value of {{ $field.Name.GoCase }}
			func (r {{ $struct }}) Set(value {{ $field.Type.Value }}) {{ $setReturnStruct }} {
				return {{ $setReturnStruct }}{
					data: field{
						name:   "{{ $field.Name.CamelCase }}",
						value:  value,
					},
				}
			}
		{{ end }}

		{{ $returnStruct := "" }}
		{{ if or ($field.IsID) ($field.IsUnique) }}
			{{ $returnStruct = (print $name "ParamsUnique") }}
		{{ else }}
			{{ $returnStruct = (print $name "Params") }}
		{{ end }}

		{{ if $field.Kind.IncludeInStruct }}
			{{/* Provide an `Equals` method for most types. */}}
			func (r {{ $struct }}) Equals(value {{ $field.Type.Value }}) {{ $returnStruct }} {
				return {{ $returnStruct }}{
					data: field{
						name:   "{{ $field.Name.CamelCase }}",
						value:  value,
					},
				}
			}

			{{/* Provide an `In` method for most types. */}}
			func (r {{ $struct }}) In(values []{{ $field.Type.Value }}) {{ $returnStruct }} {
				f := field{
					name:   "{{ $field.Name.CamelCase }}",
					action: "in",
					list:   true,
				}
				for _, v := range values {
					f.fields = append(f.fields, field{
						value: v,
					})
				}
				return {{ $returnStruct }}{
					data: f,
				}
			}

			{{ if not $field.IsRequired }}
				func (r {{ $struct }}) EqualsOptional(value *{{ $field.Type.Value }}) {{ $returnStruct }} {
					return {{ $returnStruct }}{
						data: field{
							name:  "{{ $field.Name.CamelCase }}",
							value: value,
						},
					}
				}

				func (r {{ $struct }}) IsNull() {{ $returnStruct }} {
					var str *string = nil
					return {{ $returnStruct }}{
						data: field{
							name:  "{{ $field.Name.CamelCase }}",
							value: str,
						},
					}
				}
			{{ end }}

			func (r {{ $struct }}) Order(direction Direction) {{ $returnStruct }} {
				return {{ $returnStruct }}{
					data: field{
						name:   "{{ $field.Name.CamelCase }}",
						value: direction,
					},
				}
			}
		{{ end }}

		{{/* Provide type-specific methods. */}}
		{{ range $type := $.DMMF.Types }}
			{{ if eq $field.Type $type.Name }}
				{{ range $method := $type.Methods }}
					func (r {{ $struct }}) {{ $method.Name }}(value {{ $field.Type.Value }}) {{ $returnStruct }} {
						return {{ $returnStruct }}{
							data: field{
								action: "{{ $method.Action }}",
								name:   "{{ $field.Name.CamelCase }}",
								value:  value,
							},
						}
					}
				{{ end }}
			{{ end }}
		{{ end }}
	{{ end }}
{{ end }}
